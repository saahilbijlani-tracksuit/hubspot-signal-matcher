"""\nSupabase Vector Database Client\n"""\nimport os\nfrom typing import Optional, List\nfrom supabase import create_client, Client\n\n\nclass SupabaseClient:\n    def __init__(self, url: Optional[str] = None, key: Optional[str] = None):\n        self.url = url or os.environ.get("SUPABASE_URL")\n        self.key = key or os.environ.get("SUPABASE_KEY")\n        if not self.url or not self.key:\n            raise ValueError("Supabase URL and key required")\n        self.client: Client = create_client(self.url, self.key)\n    \n    def upsert_company(self, hubspot_id: str, name: str, domain: str, embedding: List[float], embedded_text: str) -> bool:\n        try:\n            self.client.table("companies").upsert({\n                "hubspot_id": hubspot_id, "name": name, "domain": domain,\n                "embedding": embedding, "embedded_text": embedded_text\n            }, on_conflict="hubspot_id").execute()\n            return True\n        except Exception as e:\n            print(f"Error upserting company {hubspot_id}: {e}")\n            return False\n    \n    def upsert_companies_batch(self, companies: List[dict]) -> int:\n        try:\n            self.client.table("companies").upsert(companies, on_conflict="hubspot_id").execute()\n            return len(companies)\n        except Exception as e:\n            print(f"Error batch upserting companies: {e}")\n            return 0\n    \n    def search_companies(self, embedding: List[float], threshold: float = 0.85, limit: int = 10) -> List[dict]:\n        try:\n            response = self.client.rpc("search_companies", {\n                "query_embedding": embedding, "match_threshold": threshold, "match_count": limit\n            }).execute()\n            return response.data or []\n        except Exception as e:\n            print(f"Error searching companies: {e}")\n            return []\n    \n    def upsert_contact(self, hubspot_id: str, firstname: str, lastname: str, company: str, embedding: List[float], embedded_text: str) -> bool:\n        try:\n            self.client.table("contacts").upsert({\n                "hubspot_id": hubspot_id, "firstname": firstname, "lastname": lastname,\n                "company": company, "embedding": embedding, "embedded_text": embedded_text\n            }, on_conflict="hubspot_id").execute()\n            return True\n        except Exception as e:\n            print(f"Error upserting contact {hubspot_id}: {e}")\n            return False\n    \n    def upsert_contacts_batch(self, contacts: List[dict]) -> int:\n        try:\n            self.client.table("contacts").upsert(contacts, on_conflict="hubspot_id").execute()\n            return len(contacts)\n        except Exception as e:\n            print(f"Error batch upserting contacts: {e}")\n            return 0\n    \n    def search_contacts(self, embedding: List[float], threshold: float = 0.85, limit: int = 10) -> List[dict]:\n        try:\n            response = self.client.rpc("search_contacts", {\n                "query_embedding": embedding, "match_threshold": threshold, "match_count": limit\n            }).execute()\n            return response.data or []\n        except Exception as e:\n            print(f"Error searching contacts: {e}")\n            return []\n    \n    def get_company_count(self) -> int:\n        try:\n            response = self.client.table("companies").select("id", count="exact").execute()\n            return response.count or 0\n        except: return 0\n    \n    def get_contact_count(self) -> int:\n        try:\n            response = self.client.table("contacts").select("id", count="exact").execute()\n            return response.count or 0\n        except: return 0\n    \n    def update_sync_metadata(self, entity_type: str, records_synced: int) -> bool:\n        try:\n            self.client.table("sync_metadata").upsert({\n                "entity_type": entity_type, "last_sync_at": "now()", "records_synced": records_synced\n            }, on_conflict="entity_type").execute()\n            return True\n        except: return False\n    \n    def log_match(self, signal_id: str, matched_type: str, matched_hubspot_id: str, confidence: float, association_created: bool) -> bool:\n        try:\n            self.client.table("match_history").insert({\n                "signal_id": signal_id, "matched_type": matched_type,\n                "matched_hubspot_id": matched_hubspot_id, "confidence": confidence,\n                "association_created": association_created\n            }).execute()\n            return True\n        except: return False\n    \n    def get_embedding_stats(self) -> dict:\n        try:\n            response = self.client.table("embedding_stats").select("*").execute()\n            return {row["entity_type"]: row for row in response.data}\n        except:\n            return {}\n