"""\nHubSpot API Client\n\nHandles all interactions with HubSpot CRM.\n"""\n\nimport os\nfrom typing import Optional, Iterator\nfrom hubspot import HubSpot\n\n\nclass HubSpotClient:\n    SIGNAL_OBJECT_TYPE = "2-54609655"\n    COMPANY_OBJECT_TYPE = "0-2"\n    CONTACT_OBJECT_TYPE = "0-1"\n    SIGNAL_TO_COMPANY_ASSOCIATION = 421\n    SIGNAL_TO_CONTACT_ASSOCIATION = None\n    \n    def __init__(self, access_token: Optional[str] = None):\n        self.access_token = access_token or os.environ.get("HUBSPOT_ACCESS_TOKEN")\n        if not self.access_token:\n            raise ValueError("HubSpot access token required")\n        self.client = HubSpot(access_token=self.access_token)\n        self._discover_association_types()\n    \n    def _discover_association_types(self):\n        try:\n            response = self.client.crm.associations.v4.schema.definitions_api.get_all(\n                from_object_type=self.SIGNAL_OBJECT_TYPE,\n                to_object_type=self.CONTACT_OBJECT_TYPE\n            )\n            if response.results:\n                self.SIGNAL_TO_CONTACT_ASSOCIATION = response.results[0].type_id\n        except Exception as e:\n            print(f"Warning: Could not discover association types: {e}")\n    \n    def get_signal(self, signal_id: str) -> dict:\n        properties = ["signal_name", "signal_description", "signal_citation",\n                      "signal_type", "signal_status", "signal_origin", "signal_weighting"]\n        response = self.client.crm.objects.basic_api.get_by_id(\n            object_type=self.SIGNAL_OBJECT_TYPE, object_id=signal_id,\n            properties=properties,\n            associations=[self.COMPANY_OBJECT_TYPE, self.CONTACT_OBJECT_TYPE]\n        )\n        return {"id": response.id, "properties": response.properties,\n                "associations": self._parse_associations(response.associations)}\n    \n    def _parse_associations(self, associations) -> dict:\n        result = {"companies": [], "contacts": []}\n        if not associations: return result\n        for obj_type, assoc_list in associations.items():\n            if "company" in obj_type.lower():\n                result["companies"] = [a.to_object_id for a in assoc_list.results]\n            elif "contact" in obj_type.lower():\n                result["contacts"] = [a.to_object_id for a in assoc_list.results]\n        return result\n    \n    def list_signals_without_associations(self, limit: int = 100) -> list:\n        response = self.client.crm.objects.search_api.do_search(\n            object_type=self.SIGNAL_OBJECT_TYPE,\n            public_object_search_request={\n                "filterGroups": [], "limit": limit,\n                "properties": ["signal_name", "signal_description", "signal_citation", "signal_type"]\n            }\n        )\n        return [{"id": obj.id, "properties": obj.properties} for obj in response.results]\n    \n    def list_companies(self, limit: int = 100, after: Optional[str] = None, modified_after: Optional[str] = None) -> dict:\n        properties = ["name", "domain", "hs_lastmodifieddate"]\n        if modified_after:\n            response = self.client.crm.companies.search_api.do_search(\n                public_object_search_request={\n                    "filterGroups": [{"filters": [{"propertyName": "hs_lastmodifieddate", "operator": "GTE", "value": modified_after}]}],\n                    "properties": properties, "limit": limit, "after": after or "0"\n                }\n            )\n        else:\n            response = self.client.crm.companies.basic_api.get_page(limit=limit, after=after, properties=properties)\n        results = [{"id": c.id, "name": c.properties.get("name", ""), "domain": c.properties.get("domain", "")} for c in response.results]\n        return {"results": results, "paging": {"next": response.paging.next.after if response.paging and response.paging.next else None}}\n    \n    def iter_all_companies(self, modified_after: Optional[str] = None) -> Iterator[dict]:\n        after = None\n        while True:\n            page = self.list_companies(limit=100, after=after, modified_after=modified_after)\n            for company in page["results"]: yield company\n            after = page["paging"]["next"]\n            if not after: break\n    \n    def list_contacts(self, limit: int = 100, after: Optional[str] = None, modified_after: Optional[str] = None) -> dict:\n        properties = ["firstname", "lastname", "company", "hs_lastmodifieddate"]\n        if modified_after:\n            response = self.client.crm.contacts.search_api.do_search(\n                public_object_search_request={\n                    "filterGroups": [{"filters": [{"propertyName": "hs_lastmodifieddate", "operator": "GTE", "value": modified_after}]}],\n                    "properties": properties, "limit": limit, "after": after or "0"\n                }\n            )\n        else:\n            response = self.client.crm.contacts.basic_api.get_page(limit=limit, after=after, properties=properties)\n        results = [{"id": c.id, "firstname": c.properties.get("firstname", ""), "lastname": c.properties.get("lastname", ""), "company": c.properties.get("company", "")} for c in response.results]\n        return {"results": results, "paging": {"next": response.paging.next.after if response.paging and response.paging.next else None}}\n    \n    def iter_all_contacts(self, modified_after: Optional[str] = None) -> Iterator[dict]:\n        after = None\n        while True:\n            page = self.list_contacts(limit=100, after=after, modified_after=modified_after)\n            for contact in page["results"]: yield contact\n            after = page["paging"]["next"]\n            if not after: break\n    \n    def create_signal_company_association(self, signal_id: str, company_id: str) -> bool:\n        try:\n            self.client.crm.associations.v4.basic_api.create(\n                object_type=self.SIGNAL_OBJECT_TYPE, object_id=signal_id,\n                to_object_type=self.COMPANY_OBJECT_TYPE, to_object_id=company_id,\n                association_spec=[{"associationCategory": "HUBSPOT_DEFINED", "associationTypeId": self.SIGNAL_TO_COMPANY_ASSOCIATION}]\n            )\n            return True\n        except Exception as e:\n            print(f"Error creating Signal-Company association: {e}")\n            return False\n    \n    def create_signal_contact_association(self, signal_id: str, contact_id: str) -> bool:\n        if not self.SIGNAL_TO_CONTACT_ASSOCIATION: self._discover_association_types()\n        if not self.SIGNAL_TO_CONTACT_ASSOCIATION: return False\n        try:\n            self.client.crm.associations.v4.basic_api.create(\n                object_type=self.SIGNAL_OBJECT_TYPE, object_id=signal_id,\n                to_object_type=self.CONTACT_OBJECT_TYPE, to_object_id=contact_id,\n                association_spec=[{"associationCategory": "HUBSPOT_DEFINED", "associationTypeId": self.SIGNAL_TO_CONTACT_ASSOCIATION}]\n            )\n            return True\n        except Exception as e:\n            print(f"Error creating Signal-Contact association: {e}")\n            return False\n    \n    def get_company_count(self) -> int:\n        return self.client.crm.companies.search_api.do_search(public_object_search_request={"filterGroups": [], "limit": 1}).total\n    \n    def get_contact_count(self) -> int:\n        return self.client.crm.contacts.search_api.do_search(public_object_search_request={"filterGroups": [], "limit": 1}).total\n