"""\nHubSpot API Client\n\nHandles all interactions with HubSpot CRM:\n- Fetching Signals, Companies, and Contacts\n- Creating associations between objects\n- Pagination for bulk operations\n"""\n\nimport os\nimport requests\nfrom typing import Optional, Iterator\nfrom hubspot import HubSpot\nfrom hubspot.crm.objects import SimplePublicObjectInput\nfrom hubspot.crm.associations.v4 import BatchInputPublicDefaultAssociationMultiPost\n\n\nclass HubSpotClient:\n    """Client for HubSpot CRM operations."""\n    \n    # Custom object type IDs\n    SIGNAL_OBJECT_TYPE = "2-54609655"\n    COMPANY_OBJECT_TYPE = "0-2"\n    CONTACT_OBJECT_TYPE = "0-1"\n    \n    # Association type IDs (Signal <-> Company/Contact)\n    SIGNAL_TO_COMPANY_ASSOCIATION = 421\n    SIGNAL_TO_CONTACT_ASSOCIATION = None  # Will be discovered\n    \n    def __init__(self, access_token: Optional[str] = None):\n        """\n        Initialize HubSpot client.\n        \n        Args:\n            access_token: HubSpot Private App access token.\n                         Falls back to HUBSPOT_ACCESS_TOKEN env var.\n        """\n        self.access_token = access_token or os.environ.get("HUBSPOT_ACCESS_TOKEN")\n        if not self.access_token:\n            raise ValueError("HubSpot access token required")\n        \n        self.client = HubSpot(access_token=self.access_token)\n        \n        # Discover association type for Signal -> Contact\n        self._discover_association_types()\n    \n    def _discover_association_types(self):\n        """Discover association type IDs between Signals and other objects."""\n        try:\n            # Get Signal -> Contact association type\n            response = self.client.crm.associations.v4.schema.definitions_api.get_all(\n                from_object_type=self.SIGNAL_OBJECT_TYPE,\n                to_object_type=self.CONTACT_OBJECT_TYPE\n            )\n            if response.results:\n                self.SIGNAL_TO_CONTACT_ASSOCIATION = response.results[0].type_id\n        except Exception as e:\n            print(f"Warning: Could not discover association types: {e}")\n            # Fallback - will try to discover when needed\n    \n    # ==========================================\n    # SIGNAL OPERATIONS\n    # ==========================================\n    \n    def get_signal(self, signal_id: str) -> dict:\n        """\n        Fetch a Signal by ID with all relevant properties.\n        \n        Args:\n            signal_id: HubSpot object ID of the Signal\n            \n        Returns:\n            Signal data with properties\n        """\n        properties = [\n            "signal_name",\n            "signal_description", \n            "signal_citation",\n            "signal_type",\n            "signal_status",\n            "signal_origin",\n            "signal_weighting",\n        ]\n        \n        response = self.client.crm.objects.basic_api.get_by_id(\n            object_type=self.SIGNAL_OBJECT_TYPE,\n            object_id=signal_id,\n            properties=properties,\n            associations=[self.COMPANY_OBJECT_TYPE, self.CONTACT_OBJECT_TYPE]\n        )\n        \n        return {\n            "id": response.id,\n            "properties": response.properties,\n            "associations": self._parse_associations(response.associations)\n        }\n    \n    def _parse_associations(self, associations) -> dict:\n        """Parse associations from HubSpot response."""\n        result = {"companies": [], "contacts": []}\n        \n        if not associations:\n            return result\n            \n        for obj_type, assoc_list in associations.items():\n            if "company" in obj_type.lower():\n                result["companies"] = [a.to_object_id for a in assoc_list.results]\n            elif "contact" in obj_type.lower():\n                result["contacts"] = [a.to_object_id for a in assoc_list.results]\n        \n        return result\n    \n    def list_signals(self, limit: int = 100, after: Optional[str] = None) -> dict:\n        """\n        List signals with pagination.\n        \n        Args:\n            limit: Number of signals per page (max 100)\n            after: Pagination cursor\n            \n        Returns:\n            Dict with 'results' and 'paging' info\n        """\n        properties = [\n            "signal_name",\n            "signal_description",\n            "signal_citation",\n            "signal_type",\n            "signal_status",\n        ]\n        \n        response = self.client.crm.objects.basic_api.get_page(\n            object_type=self.SIGNAL_OBJECT_TYPE,\n            limit=limit,\n            after=after,\n            properties=properties,\n            associations=[self.COMPANY_OBJECT_TYPE, self.CONTACT_OBJECT_TYPE]\n        )\n        \n        results = []\n        for signal in response.results:\n            associations = self._parse_associations(signal.associations)\n            results.append({\n                "id": signal.id,\n                "properties": signal.properties,\n                "associations": associations\n            })\n        \n        return {\n            "results": results,\n            "paging": {\n                "next": response.paging.next.after if response.paging and response.paging.next else None\n            }\n        }\n    \n    def list_signals_without_associations(self, limit: int = 100) -> list:\n        """\n        List signals that don't have company or contact associations.\n        \n        Args:\n            limit: Maximum number of signals to return\n            \n        Returns:\n            List of signal dicts without associations\n        """\n        unassociated = []\n        after = None\n        \n        while len(unassociated) < limit:\n            page = self.list_signals(limit=min(100, limit - len(unassociated)), after=after)\n            \n            for signal in page["results"]:\n                associations = signal.get("associations", {})\n                companies = associations.get("companies", [])\n                contacts = associations.get("contacts", [])\n                \n                # Include if no associations\n                if not companies and not contacts:\n                    unassociated.append(signal)\n                    \n                    if len(unassociated) >= limit:\n                        break\n            \n            after = page["paging"]["next"]\n            if not after:\n                break\n        \n        return unassociated\n    \n    # ==========================================\n    # COMPANY OPERATIONS  \n    # ==========================================\n    \n    def get_company(self, company_id: str) -> dict:\n        """Fetch a Company by ID."""\n        response = self.client.crm.companies.basic_api.get_by_id(\n            company_id=company_id,\n            properties=["name", "domain"]\n        )\n        return {\n            "id": response.id,\n            "name": response.properties.get("name", ""),\n            "domain": response.properties.get("domain", ""),\n        }\n    \n    def list_companies(\n        self, \n        limit: int = 100,\n        after: Optional[str] = None,\n        modified_after: Optional[str] = None\n    ) -> dict:\n        """\n        List companies with pagination.\n        \n        Args:\n            limit: Number of companies per page (max 100)\n            after: Pagination cursor\n            modified_after: ISO timestamp to filter by modification date\n            \n        Returns:\n            Dict with 'results' and 'paging' info\n        """\n        properties = ["name", "domain", "hs_lastmodifieddate"]\n        \n        if modified_after:\n            # Use search API for filtering by date\n            filter_groups = [{\n                "filters": [{\n                    "propertyName": "hs_lastmodifieddate",\n                    "operator": "GTE",\n                    "value": modified_after\n                }]\n            }]\n            response = self.client.crm.companies.search_api.do_search(\n                public_object_search_request={\n                    "filterGroups": filter_groups,\n                    "properties": properties,\n                    "limit": limit,\n                    "after": after or "0"\n                }\n            )\n        else:\n            response = self.client.crm.companies.basic_api.get_page(\n                limit=limit,\n                after=after,\n                properties=properties\n            )\n        \n        results = []\n        for company in response.results:\n            results.append({\n                "id": company.id,\n                "name": company.properties.get("name", ""),\n                "domain": company.properties.get("domain", ""),\n            })\n        \n        return {\n            "results": results,\n            "paging": {\n                "next": response.paging.next.after if response.paging and response.paging.next else None\n            }\n        }\n    \n    def iter_all_companies(self, modified_after: Optional[str] = None) -> Iterator[dict]:\n        """\n        Iterate through all companies with automatic pagination.\n        \n        Args:\n            modified_after: ISO timestamp to filter by modification date\n            \n        Yields:\n            Company dictionaries\n        """\n        after = None\n        while True:\n            page = self.list_companies(limit=100, after=after, modified_after=modified_after)\n            \n            for company in page["results"]:\n                yield company\n            \n            after = page["paging"]["next"]\n            if not after:\n                break\n    \n    # ==========================================\n    # CONTACT OPERATIONS\n    # ==========================================\n    \n    def get_contact(self, contact_id: str) -> dict:\n        """Fetch a Contact by ID."""\n        response = self.client.crm.contacts.basic_api.get_by_id(\n            contact_id=contact_id,\n            properties=["firstname", "lastname", "company"]\n        )\n        return {\n            "id": response.id,\n            "firstname": response.properties.get("firstname", ""),\n            "lastname": response.properties.get("lastname", ""),\n            "company": response.properties.get("company", ""),\n        }\n    \n    def list_contacts(\n        self,\n        limit: int = 100,\n        after: Optional[str] = None,\n        modified_after: Optional[str] = None\n    ) -> dict:\n        """\n        List contacts with pagination.\n        \n        Args:\n            limit: Number of contacts per page (max 100)\n            after: Pagination cursor\n            modified_after: ISO timestamp to filter by modification date\n            \n        Returns:\n            Dict with 'results' and 'paging' info\n        """\n        properties = ["firstname", "lastname", "company", "hs_lastmodifieddate"]\n        \n        if modified_after:\n            filter_groups = [{\n                "filters": [{\n                    "propertyName": "hs_lastmodifieddate",\n                    "operator": "GTE",\n                    "value": modified_after\n                }]\n            }]\n            response = self.client.crm.contacts.search_api.do_search(\n                public_object_search_request={\n                    "filterGroups": filter_groups,\n                    "properties": properties,\n                    "limit": limit,\n                    "after": after or "0"\n                }\n            )\n        else:\n            response = self.client.crm.contacts.basic_api.get_page(\n                limit=limit,\n                after=after,\n                properties=properties\n            )\n        \n        results = []\n        for contact in response.results:\n            results.append({\n                "id": contact.id,\n                "firstname": contact.properties.get("firstname", ""),\n                "lastname": contact.properties.get("lastname", ""),\n                "company": contact.properties.get("company", ""),\n            })\n        \n        return {\n            "results": results,\n            "paging": {\n                "next": response.paging.next.after if response.paging and response.paging.next else None\n            }\n        }\n    \n    def iter_all_contacts(self, modified_after: Optional[str] = None) -> Iterator[dict]:\n        """\n        Iterate through all contacts with automatic pagination.\n        \n        Args:\n            modified_after: ISO timestamp to filter by modification date\n            \n        Yields:\n            Contact dictionaries\n        """\n        after = None\n        while True:\n            page = self.list_contacts(limit=100, after=after, modified_after=modified_after)\n            \n            for contact in page["results"]:\n                yield contact\n            \n            after = page["paging"]["next"]\n            if not after:\n                break\n    \n    # ==========================================\n    # ASSOCIATION OPERATIONS\n    # ==========================================\n    \n    def create_signal_company_association(self, signal_id: str, company_id: str) -> bool:\n        """\n        Create an association between a Signal and a Company.\n        \n        Args:\n            signal_id: HubSpot ID of the Signal\n            company_id: HubSpot ID of the Company\n            \n        Returns:\n            True if successful\n        """\n        try:\n            # Use direct API call for custom object associations\n            # The SDK has issues with custom object type IDs\n            url = f"https://api.hubapi.com/crm/v4/objects/{self.SIGNAL_OBJECT_TYPE}/{signal_id}/associations/{self.COMPANY_OBJECT_TYPE}/{company_id}"\n            \n            headers = {\n                "Authorization": f"Bearer {self.access_token}",\n                "Content-Type": "application/json"\n            }\n            \n            payload = [{\n                "associationCategory": "HUBSPOT_DEFINED",\n                "associationTypeId": self.SIGNAL_TO_COMPANY_ASSOCIATION\n            }]\n            \n            response = requests.put(url, headers=headers, json=payload)\n            \n            if response.status_code in [200, 201]:\n                return True\n            else:\n                print(f"Error creating Signal-Company association: {response.status_code} - {response.text}")\n                return False\n                \n        except Exception as e:\n            print(f"Error creating Signal-Company association: {e}")\n            return False\n    \n    def create_signal_contact_association(self, signal_id: str, contact_id: str) -> bool:\n        """\n        Create an association between a Signal and a Contact.\n        \n        Args:\n            signal_id: HubSpot ID of the Signal\n            contact_id: HubSpot ID of the Contact\n            \n        Returns:\n            True if successful\n        """\n        if not self.SIGNAL_TO_CONTACT_ASSOCIATION:\n            # Try to discover if not already known\n            self._discover_association_types()\n            \n        if not self.SIGNAL_TO_CONTACT_ASSOCIATION:\n            print("Warning: Signal-Contact association type not found")\n            return False\n            \n        try:\n            # Use direct API call for custom object associations\n            url = f"https://api.hubapi.com/crm/v4/objects/{self.SIGNAL_OBJECT_TYPE}/{signal_id}/associations/{self.CONTACT_OBJECT_TYPE}/{contact_id}"\n            \n            headers = {\n                "Authorization": f"Bearer {self.access_token}",\n                "Content-Type": "application/json"\n            }\n            \n            payload = [{\n                "associationCategory": "HUBSPOT_DEFINED",\n                "associationTypeId": self.SIGNAL_TO_CONTACT_ASSOCIATION\n            }]\n            \n            response = requests.put(url, headers=headers, json=payload)\n            \n            if response.status_code in [200, 201]:\n                return True\n            else:\n                print(f"Error creating Signal-Contact association: {response.status_code} - {response.text}")\n                return False\n                \n        except Exception as e:\n            print(f"Error creating Signal-Contact association: {e}")\n            return False\n    \n    def get_company_count(self) -> int:\n        """Get total number of companies in HubSpot."""\n        response = self.client.crm.companies.search_api.do_search(\n            public_object_search_request={\n                "filterGroups": [],\n                "limit": 1\n            }\n        )\n        return response.total\n    \n    def get_contact_count(self) -> int:\n        """Get total number of contacts in HubSpot."""\n        response = self.client.crm.contacts.search_api.do_search(\n            public_object_search_request={\n                "filterGroups": [],\n                "limit": 1\n            }\n        )\n        return response.total\n