"""\nSignal Matcher - Company Name Extraction Approach\n\nMatches HubSpot Signals to Companies by:\n1. Extracting company names from signal text using OpenAI\n2. Searching for those companies by name in Supabase\n3. Creating associations for matches\n"""\n\nimport os\nimport json\nimport traceback\nfrom typing import List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom openai import OpenAI\n\nfrom .hubspot_client import HubSpotClient\nfrom .supabase_client import SupabaseClient\nfrom .embeddings import EmbeddingGenerator\n\n\ndef log(msg):\n    """Log with timestamp."""\n    print(f"[{datetime.now().strftime('%H:%M:%S')}] {msg}", flush=True)\n\n\n@dataclass\nclass MatchResult:\n    """Result of a matching operation."""\n    hubspot_id: str\n    name: str\n    match_type: str  # 'company' or 'contact'\n    similarity: float\n    association_created: bool = False\n\n\nclass SignalMatcher:\n    """Matches HubSpot Signals to Companies using name extraction."""\n    \n    def __init__(\n        self,\n        hubspot_token: Optional[str] = None,\n        supabase_url: Optional[str] = None,\n        supabase_key: Optional[str] = None,\n        openai_key: Optional[str] = None,\n        confidence_threshold: float = 0.80\n    ):\n        """Initialize the signal matcher."""\n        self.hubspot = HubSpotClient(access_token=hubspot_token)\n        self.supabase = SupabaseClient(url=supabase_url, key=supabase_key)\n        self.embeddings = EmbeddingGenerator(api_key=openai_key)\n        self.threshold = float(os.environ.get("CONFIDENCE_THRESHOLD", confidence_threshold))\n        \n        # Initialize OpenAI client for name extraction\n        api_key = openai_key or os.environ.get("OPENAI_API_KEY")\n        self.openai = OpenAI(api_key=api_key)\n    \n    def extract_company_names(self, text: str) -> List[str]:\n        """\n        Extract company/brand names from signal text using OpenAI.\n        \n        Args:\n            text: Signal description and citation text\n            \n        Returns:\n            List of company names mentioned in the text\n        """\n        try:\n            response = self.openai.chat.completions.create(\n                model="gpt-4o-mini",\n                messages=[\n                    {\n                        "role": "system",\n                        "content": """Extract all company, brand, or organization names from the text.\nReturn ONLY a JSON array of strings with the exact company names as they appear.\nDo not include generic terms like \"the company\" or person names.\nIf no companies are mentioned, return an empty array [].\n\nExamples:\n- \"GoPro's headquarters will be demolished\" → [\"GoPro\"]\n- \"Ted Baker launches Ted Baker Sport\" → [\"Ted Baker\"]\n- \"L'Oreal and Pernod Ricard executives visit India\" → [\"L'Oreal\", \"Pernod Ricard\"]\n- \"The new store opened downtown\" → []"""\n                    },\n                    {\n                        "role": "user",\n                        "content": text[:2000]  # Limit to 2000 chars\n                    }\n                ],\n                temperature=0,\n                max_tokens=500\n            )\n            \n            result = response.choices[0].message.content.strip()\n            # Parse JSON array\n            if result.startswith("["):\n                companies = json.loads(result)\n                return [c.strip() for c in companies if c and isinstance(c, str)]\n            return []\n            \n        except Exception as e:\n            log(f"  Error extracting company names: {e}")\n            return []\n    \n    def search_company_by_name(self, company_name: str) -> List[dict]:\n        """\n        Search for a company by name in Supabase using text matching.\n        \n        Args:\n            company_name: Name to search for\n            \n        Returns:\n            List of matching company records\n        """\n        try:\n            # Sanitize company name for SQL ILIKE query\n            # Remove/escape characters that break PostgREST parsing\n            sanitized_name = company_name.replace(",", "").replace(".", "").replace("'", "''")\n            \n            # Use Supabase client to search by name\n            results = self.supabase.client.table("companies").select(\n                "hubspot_id, name, domain"\n            ).or_(\n                f"name.ilike.%{sanitized_name}%,domain.ilike.%{sanitized_name}%"\n            ).limit(5).execute()\n            \n            matches = []\n            for record in results.data:\n                # Calculate a simple similarity score based on name match\n                name_lower = record["name"].lower() if record["name"] else ""\n                search_lower = company_name.lower()\n                \n                # Exact match = 1.0, contains = 0.9, partial = 0.8\n                if name_lower == search_lower:\n                    similarity = 1.0\n                elif search_lower in name_lower or name_lower in search_lower:\n                    similarity = 0.9\n                else:\n                    similarity = 0.8\n                \n                matches.append({\n                    "hubspot_id": record["hubspot_id"],\n                    "name": record["name"],\n                    "domain": record.get("domain", ""),\n                    "similarity": similarity\n                })\n            \n            return matches\n            \n        except Exception as e:\n            log(f"  Error searching for '{company_name}': {e}")\n            return []\n    \n    def match_signal(self, signal_id: str) -> dict:\n        """Match a signal to companies using name extraction."""\n        log(f"Processing signal {signal_id}...")\n        \n        try:\n            # 1. Fetch signal from HubSpot\n            signal = self.hubspot.get_signal(signal_id)\n            properties = signal["properties"]\n            \n            signal_type = properties.get("signal_type") or "company"\n            description = properties.get("signal_description", "") or ""\n            citation = properties.get("signal_citation", "") or ""\n            \n            log(f"  Signal type: {signal_type}")\n            log(f"  Description: {description[:100]}..." if len(description) > 100 else f"  Description: {description}")\n            \n            # Check existing associations\n            existing_companies = signal["associations"].get("companies", [])\n            existing_contacts = signal["associations"].get("contacts", [])\n            \n            if existing_companies or existing_contacts:\n                log(f"  Already has: {len(existing_companies)} companies, {len(existing_contacts)} contacts")\n            \n            # Combine text for extraction\n            full_text = f"{description} {citation}".strip()\n            \n            if not full_text:\n                log("  ERROR: No text content in signal")\n                return {\n                    "signal_id": signal_id,\n                    "signal_type": signal_type,\n                    "error": "No text content",\n                    "company_matches": [],\n                    "contact_matches": [],\n                    "total_matches": 0,\n                    "associations_created": 0\n                }\n            \n            # 2. Extract company names from text\n            log("  Extracting company names...")\n            company_names = self.extract_company_names(full_text)\n            log(f"  Found companies: {company_names}")\n            \n            if not company_names:\n                log("  No company names found in text")\n                return {\n                    "signal_id": signal_id,\n                    "signal_type": signal_type,\n                    "extracted_companies": [],\n                    "company_matches": [],\n                    "contact_matches": [],\n                    "total_matches": 0,\n                    "associations_created": 0\n                }\n            \n            # 3. Search for each company name\n            company_matches: List[MatchResult] = []\n            seen_ids = set()  # Avoid duplicates\n            \n            for company_name in company_names:\n                log(f"  Searching for: {company_name}")\n                results = self.search_company_by_name(company_name)\n                \n                for result in results:\n                    if result["hubspot_id"] not in seen_ids and result["similarity"] >= self.threshold:\n                        seen_ids.add(result["hubspot_id"])\n                        match = MatchResult(\n                            hubspot_id=result["hubspot_id"],\n                            name=result["name"],\n                            match_type="company",\n                            similarity=result["similarity"]\n                        )\n                        company_matches.append(match)\n                        log(f"    Match: {match.name} ({match.similarity:.0%})")\n            \n            # 4. Create associations\n            associations_created = 0\n            \n            for match in company_matches:\n                if match.hubspot_id not in existing_companies:\n                    success = self.hubspot.create_signal_company_association(\n                        signal_id=signal_id,\n                        company_id=match.hubspot_id\n                    )\n                    match.association_created = success\n                    if success:\n                        associations_created += 1\n                        log(f"    Created: Signal → {match.name}")\n                    \n                    self.supabase.log_match(\n                        signal_id=signal_id,\n                        matched_type="company",\n                        matched_hubspot_id=match.hubspot_id,\n                        confidence=match.similarity,\n                        association_created=success\n                    )\n                else:\n                    log(f"    Skipped {match.name} (already associated)")\n            \n            # 5. Return results\n            result = {\n                "signal_id": signal_id,\n                "signal_type": signal_type,\n                "extracted_companies": company_names,\n                "company_matches": [\n                    {\n                        "hubspot_id": m.hubspot_id,\n                        "name": m.name,\n                        "similarity": m.similarity,\n                        "association_created": m.association_created\n                    }\n                    for m in company_matches\n                ],\n                "contact_matches": [],\n                "total_matches": len(company_matches),\n                "associations_created": associations_created\n            }\n            \n            if company_matches:\n                log(f"  Completed: {len(company_matches)} matches, {associations_created} associations")\n            else:\n                log(f"  No matches found in database for: {company_names}")\n            \n            return result\n            \n        except Exception as e:\n            log(f"  ERROR: {e}")\n            traceback.print_exc()\n            return {\n                "signal_id": signal_id,\n                "error": str(e),\n                "company_matches": [],\n                "contact_matches": [],\n                "total_matches": 0,\n                "associations_created": 0\n            }\n\n\ndef match_signal_standalone(signal_id: str) -> dict:\n    """Standalone function to match a signal."""\n    matcher = SignalMatcher()\n    return matcher.match_signal(signal_id)\n